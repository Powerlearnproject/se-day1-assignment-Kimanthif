[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18472826&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software Engineering is a branch of computer science, where it deals with design, development, deployment, testing and ,maintainance of software applications for end users.

Importance of seoftware engineering includes:
1. Enablement of digital transformation - through software engineering, organizations and users in general are able to transform their businesses and process by getting custom software solutions that address their problems.
2. Creation of wide and reliable systems - software engineers employ thorough development processes and quality assurance techniques to create reliable software systems.
3. facilitation of seamlesss user experience - UX is important in today's tech-driven world. Software engineering focuses on designing intuitive interfaces and user-friendly interactions that enhance the overall user experience.
4. Support for scalability and flexibility - Software solutions must be scalable and flexible to accomodate changing business requirements and evolving user needs.


Identify and describe at least three key milestones in the evolution of software engineering.

Mastering complexity
Mastering process
Mastering machine



List and briefly explain the phases of the Software Development Life Cycle.

SDLC consists of a precise plan that describes how to develop, maintain, replace and enhance specific software. There are 6 stages that are followed during SDLC. They include:
1. Planing and requirement analysis. Here the project manager leads the team in planning, defination of scope, setting of objectives and goals. Resources planning is also done.
2. Defining requirements. All the requirements for the target software are specified. Functional requirements, technical requirements are all defined. Then requirement are reviewed and approved by relevant stakeholders. This is fulfilled by utilizing SRS(Software Requirement Specification). This document specifies all those things that needs to be defined and created during the entire project cycle.
3. Design architecture. Here multiple designs for the product architecture are created for the stakeholders to choose the most practical and logical design. There are low level designs and high level designs.
4. Development - developers use specific programming code as per the design to develop the product. In development, coding standards are adhered to, a scalable code, version control and code review is done.
5. Product testing and intergration. At this stage, testing of the product is important to ensure smooth execution. This ensure s probable flaws are tracked, fixed and retested ensuring the product meets the quality requirement. Documentation, training and support is crucial at this stage. Testing can be manual or automated.
6. Deployment and maintainance - After successful testing, release of the product is done in phases as per the organization's strategy. This is to gauge how the product does in the live environment. Once feedback is gotten that it is successful, the organization then releases it as a whole. However, monitoring is done and feedback is encouraged.



Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall model follows a systematic routine of executing tasks in a project. It allows completion of one task before the next one can be executed. This leaves it to be rigid as it does not allow changes once a phase has been completed. Feedback to the customer is after the product is built. This kind of model is more suitable for large projects especially government ones where there is no time and budget constraint.

Agile model was designed to adapt to changing requests quickly. In this model, project timeframe is short and completion is usually quick. This model allows small iterations to be achieved within the shortest time. Continuous feedback to customer. Change is easliy handled during the sprints. This model can be used in building a website for a user(hospital)

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Quality Assurance Engineer is responsible for:
- Identifying bugs, system flaws and other software issues in a product before it is released to the public.
- Confirms that the product or services meet company and industry standards.
- Overseeing product problem resolutions, running software compatibility tests and driving product improvements.

2. Software developer:
- Builds softwares.
- Creates proper software documentation.
- Develops updates and upgrades for the softwares they build.
- Resolves issues for existing software.

3. Project Manager:
- Supervises the deployment process of a product.
- Generates ideas for market entry, manages pricing policy, plan and control tasks, set goals and metrics to achieve the compay's objectives and targets.
- Collaborates with the whole team.
- Holds meetings and ensures team members know what is expected of them.
- Maintaining documentation
- Facilitates and encourages the implementation of new softwares or modules.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently.
Importance of IDEs include:

Code editing automation
Programming languages have rules for how statements must be structured. Because an IDE knows these rules, it contains many intelligent features for automatically writing or editing the source code.

Syntax highlighting
An IDE can format the written text by automatically making some words bold or italic, or by using different font colors. These visual cues make the source code more readable and give instant feedback about accidental syntax errors.

Intelligent code completion
Various search terms show up when you start typing words in a search engine. Similarly, an IDE can make suggestions to complete a code statement when the developer begins typing.

Refactoring support
Code refactoring is the process of restructuring the source code to make it more efficient and readable without changing its core functionality. IDEs can auto-refactor to some extent, allowing developers to improve their code quickly and easily. Other team members understand readable code faster, which supports collaboration within the team.

Local build automation
IDEs increase programmer productivity by performing repeatable development tasks that are typically part of every code change. The following are some examples of regular coding tasks that an IDE carries out.

Compilation
An IDE compiles or converts the code into a simplified language that the operating system can understand. Some programming languages implement just-in-time compiling, in which the IDE converts human-readable code into machine code from within the application.

Testing
The IDE allows developers to automate unit tests locally before the software is integrated with other developers' code and more complex integration tests are run.

Debugging
Debugging is the process of fixing any errors or bugs that testing reveals. One of the biggest values of an IDE for debugging purposes is that you can step through the code, line by line, as it runs and inspect code behavior. IDEs also integrate several debugging tools that highlight bugs caused by human error in real time, even as the developer is typing.

Version control systems(VCS) are a category of software tools that helps in recording changes made to files by keeping a track of modifications done in the code.
Importance of VCS includes:

- Enhances the project development speed by providing efficient collaboration,
Leverages the productivity, expedites product delivery, and skills of the employees through better communication and assistance.
- Reduce possibilities of errors and conflicts meanwhile project development through traceability to every small change.
- Employees or contributors of the project can contribute from anywhere irrespective of the different geographical locations through this VCS.
- For each different contributor to the project, a different working copy is maintained and not merged to the main file unless the working copy is validated. The most popular example is Git, Helix core, Microsoft TFS.
- Helps in recovery in case of any disaster or contingent situation,
Informs us about Who, What, When, Why changes have been made.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Challenges faced by software engineers include:
- Complexity: Software systems have become increasingly complex, making it difficult for developers to understand and manage all the components of a system.
- Maintaining Quality: Ensuring the quality of software systems can be a challenging task, as developers need to account for various factors such as performance, security, and usability.
- Meeting Deadlines: Developers often work under tight deadlines, which can make it difficult to ensure the quality of the final product.
Keeping up with new technologies: Software development is a rapidly evolving field, and developers must constantly learn new technologies and programming languages to stay current.
- Managing changing requirements: Software development projects often involve working with changing requirements, which can make it difficult for developers to plan and manage their work effectively.
- Collaboration: Collaborating with other team members, such as project managers, designers, and other developers, can be challenging as everyone have different working styles and goals.
- Debugging: Debugging software can be time-consuming and complex, particularly for large and complex systems.
- Dealing with legacy code: Developers often have to work with legacy code, which can be difficult to understand and maintain.
- Managing complexity in distributed development: Developing software in a distributed environment, where team members are located in different parts of the world, can be challenging, as it requires effective communication and coordination.
- Balancing short-term and long-term goals: While developers want to deliver the software as soon as possible, they also want to ensure that the software is maintainable and scalable in the long-term.
 
HOW TO FACE THIS CHALLENGES:
Software developers can face the challenges mentioned above by implementing the following strategies:

- Complexity: Use design patterns and architecture principles to simplify the software systems and make it easy to understand and manage.
- Maintaining Quality: Use software testing and quality assurance techniques to ensure the quality of software systems, and conduct code reviews to identify and fix issues early on.
- Meeting Deadlines: Use project management techniques such as Agile development and Scrum to plan and manage work effectively.
- Keeping up with new technologies: Continuously learn and explore new technologies and programming languages to stay current.
- Managing changing requirements: Use flexible development methodologies such as Agile and Scrum to handle changing requirements effectively.
- Collaboration: Use collaboration tools such as communication platforms and version control systems to facilitate effective collaboration among team members.
- Debugging: Use debugging tools and techniques to simplify the debugging process and make it more efficient.
- Dealing with legacy code: Use refactoring techniques to improve the quality and maintainability of legacy code.
- Managing complexity in distributed development: Use communication tools and techniques to effectively coordinate and communicate with team members located in different parts of the world.
- Balancing short-term and long-term goals: Use techniques such as Test-driven development and Continuous Integration to balance short-term goals and long-term goals.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit testing:
 - Unit testing is a method of testing individual units or components of a software application. It is typically done by developers and is used to ensure that the individual units of the software are working as intended. Unit tests are usually automated and are designed to test specific parts of the code, such as a particular function or method. Unit testing is done at the lowest level of the software development process , where individual units of code are tested in isolation.

Importance of unit testing includes:
- It helps to identify bugs early in the development process before they become more difficult and expensive to fix.
- It helps to ensure that changes to the code do not introduce new bugs.
- It makes the code more modular and easier to understand and maintain.
- It helps to improve the overall quality and reliability of the software.

Integration testing:
- Integration testing is a method of testing how different units or components of a software application interact with each other. It is used to identify and resolve any issues that may arise when different units of the software are combined. Integration testing is typically done after unit testing and before functional testing and is used to verify that the different units of the software work together as intended.

Importance of intergration testing includes:
- It helps to identify and resolve issues that may arise when different units of the software are combined.
- It helps to ensure that the different units of the software work together as intended.
- It helps to improve the overall reliability and stability of the software.
- It’s important to keep in mind that Integration testing is essential for complex systems where different components are integrated.
* As with unit testing, integration testing is only one aspect of software testing and it should be used in combination with other types of testing such as unit testing, functional testing, and acceptance testing to ensure that the software meets the needs of its users.

System testing:
- System testing is a type of software testing that evaluates the overall functionality and performance of a complete and fully integrated software solution. It tests if the system meets the specified requirements and if it is suitable for delivery to the end-users. This type of testing is performed after the integration testing and before the acceptance testing.

Importance of system testing includes:
- The testers do not require more knowledge of programming to carry out this testing.
- It will test the entire product or software so that we will easily detect the errors or defects that cannot be identified during the unit testing and integration testing.
- The testing environment is similar to that of the real-time production or business environment.
- It checks the entire functionality of the system with different test scripts and also it covers the technical and business requirements of clients.
- After this testing, the product will almost cover all the possible bugs or errors and hence the development team will confidently go ahead with acceptance testing.

 Acceptance Testing
-It is formal testing according to user needs, requirements, and business processes conducted to determine whether a system satisfies the acceptance criteria or not and to enable the users, customers, or other authorized entities to determine whether to accept the system or not.

Importance of Acceptance Testing:
- This testing helps the project team to know the further requirements from the users directly as it involves the users for testing.
Automated test execution.
- It brings confidence and satisfaction to the clients as they are directly involved in the testing process.
- It is easier for the user to describe their requirement.
- It covers only the Black-Box testing process and hence the entire functionality of the product will be tested.



#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

- Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs. Even though generative AI attempts to mimic humans, it requires detailed instructions to create high-quality and relevant output.

Importance of prompt engineering:

Greater developer control
Prompt engineering gives developers more control over users' interactions with the AI. Effective prompts provide intent and establish context to the large language models. They help the AI refine the output and present it concisely in the required format.

They also prevent your users from misusing the AI or requesting something the AI does not know or cannot handle accurately. For instance, you may want to limit your users from generating inappropriate content in a business AI application.

Improved user experience
Users avoid trial and error and still receive coherent, accurate, and relevant responses from AI tools. Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models’ training data.

Further, it enhances the user-AI interaction so the AI understands the user's intention even with minimal input. For example, requests to summarize a legal document and a news article get different results adjusted for style and tone. This is true even if both users just tell the application, "Summarize this document."

Increased flexibility
Higher levels of abstraction improve AI models and allow organizations to create more flexible tools at scale. A prompt engineer can create prompts with domain-neutral instructions highlighting logical links and broad patterns. Organizations can rapidly reuse the prompts across the enterprise to expand their AI investments.



Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Example of a bad prompt:
- "Write an email to your boss about the project."

A clear prompt would be:
"Write an email to your boss breifing him about the progress on project Y"

The improved prompt is more effective because the boss will have an idea on what project is being talked about and the progress on the same.